import { type InferOptions } from '../args-parser.js';
declare const optionsSchema: {
    output: {
        type: StringConstructor;
        alias: string;
    };
    _: {
        type: [StringConstructor];
        maxItems: number;
    };
    allowMatchingProperties: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    allowUnionTypes: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    strict: (input: string) => boolean | "log";
    strictNumbers: (input: string) => boolean | "log";
    strictRequired: (input: string) => boolean | "log";
    strictSchema: (input: string) => boolean | "log";
    strictTuples: (input: string) => boolean | "log";
    strictTypes: (input: string) => boolean | "log";
    validateFormats: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    allErrors: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    comment: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    data: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    verbose: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    coerceTypes: (input: string) => boolean | "array";
    removeAdditional: (input: string) => boolean | "all" | "failing";
    useDefaults: (input: string) => boolean | "empty";
    codeEs5: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    codeEsm: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    codeFormats: StringConstructor;
    codeLines: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    codeOptimize: (input: string) => number | boolean;
    inlineRefs: (input: string) => number | boolean;
    loopEnum: ((input: string) => number) & {
        expectedValues: string[];
        parse: (input: string) => number | undefined;
    };
    loopRequired: ((input: string) => number) & {
        expectedValues: string[];
        parse: (input: string) => number | undefined;
    };
    messages: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    multipleOfPrecision: (input: string) => number | boolean;
    ownProperties: ((input: string) => boolean) & {
        expectedValues: string[];
        parse: (input: string) => boolean | undefined;
    };
    keywords: {
        type: [StringConstructor];
        alias: string;
    };
    metaSchema: {
        type: [StringConstructor];
        alias: string;
    };
    refSchema: {
        type: [StringConstructor];
        alias: string;
    };
    schema: {
        required: true;
        type: [StringConstructor];
        alias: string;
        default: () => string[];
    };
    spec: {
        type: ((input: string) => "jtd" | "draft7" | "draft2019" | "draft2020") & {
            expectedValues: string[];
            parse: (input: string) => "jtd" | "draft7" | "draft2019" | "draft2020" | undefined;
        };
    };
};
type Options = InferOptions<typeof optionsSchema>;
declare const _default: {
    options: {
        output: {
            type: StringConstructor;
            alias: string;
        };
        _: {
            type: [StringConstructor];
            maxItems: number;
        };
        allowMatchingProperties: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        allowUnionTypes: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        strict: (input: string) => boolean | "log";
        strictNumbers: (input: string) => boolean | "log";
        strictRequired: (input: string) => boolean | "log";
        strictSchema: (input: string) => boolean | "log";
        strictTuples: (input: string) => boolean | "log";
        strictTypes: (input: string) => boolean | "log";
        validateFormats: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        allErrors: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        comment: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        data: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        verbose: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        coerceTypes: (input: string) => boolean | "array";
        removeAdditional: (input: string) => boolean | "all" | "failing";
        useDefaults: (input: string) => boolean | "empty";
        codeEs5: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        codeEsm: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        codeFormats: StringConstructor;
        codeLines: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        codeOptimize: (input: string) => number | boolean;
        inlineRefs: (input: string) => number | boolean;
        loopEnum: ((input: string) => number) & {
            expectedValues: string[];
            parse: (input: string) => number | undefined;
        };
        loopRequired: ((input: string) => number) & {
            expectedValues: string[];
            parse: (input: string) => number | undefined;
        };
        messages: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        multipleOfPrecision: (input: string) => number | boolean;
        ownProperties: ((input: string) => boolean) & {
            expectedValues: string[];
            parse: (input: string) => boolean | undefined;
        };
        keywords: {
            type: [StringConstructor];
            alias: string;
        };
        metaSchema: {
            type: [StringConstructor];
            alias: string;
        };
        refSchema: {
            type: [StringConstructor];
            alias: string;
        };
        schema: {
            required: true;
            type: [StringConstructor];
            alias: string;
            default: () => string[];
        };
        spec: {
            type: ((input: string) => "jtd" | "draft7" | "draft2019" | "draft2020") & {
                expectedValues: string[];
                parse: (input: string) => "jtd" | "draft7" | "draft2019" | "draft2020" | undefined;
            };
        };
    };
    execute: typeof compile;
};
export default _default;
declare function compile(opts: Options, _args: string[]): Promise<boolean>;
