import { type Flags, type TypeFlag } from 'type-flag';
export type OptionsSchema<T = Record<string, any>> = {
    [K in keyof T & string]: Flags<T>[K] & SchemaExtras;
};
interface SchemaExtras {
    required?: boolean;
    /** This is used only for the special `_` property (positional arguments)! */
    minItems?: number;
    /** This is used only for the special `_` property (positional arguments)! */
    maxItems?: number;
}
export type InferOptions<T extends OptionsSchema> = Omit<TypeFlag<T>['flags'], '_'>;
type OptionParser<T> = ((input: string) => T) & {
    expectedValues: string[];
    parse: (input: string) => T | undefined;
};
export declare const AnyOf: <T extends (OptionParser<any> | ((...args: any[]) => any))[]>(...parsers: T) => (input: string) => ReturnType<T[number]>;
export declare const Bool: OptionParser<boolean>;
export declare const Const: <T extends string>(value: T) => OptionParser<T>;
export declare const Enum: <T extends readonly string[]>(...members: T) => OptionParser<T[number]>;
export declare const Uint: OptionParser<number>;
export declare function parseArgv<T extends OptionsSchema>(schema: T, argv: string[]): [opts: InferOptions<T>, args: string[]];
export {};
