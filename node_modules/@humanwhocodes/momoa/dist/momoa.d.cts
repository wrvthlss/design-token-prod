//-----------------------------------------------------------------------------
// Options
//-----------------------------------------------------------------------------

/**
 * The mode that Momoa runs in:
 * - "json" for regular JSON
 * - "jsonc" for JSON with C-style comments
 */
type Mode$1 = "json" | "jsonc" | "json5";

/**
 * The phase of the traversal step.
 */
type TraversalPhase$1 = "enter" | "exit";

/**
 * The type of a JSON5 Infinity or NaN value.
 * - "+" for positive Infinity or postive NaN
 * - "-" for negative Infinity or negative NaN
 * - "" for Infinity or NaN without a sign
 */
type Sign$1 = "+" | "-" | "";

/**
 * Tokenization options.
 */
interface TokenizeOptions$1 {

    /**
     * The mode to tokenize in.
     */
    readonly mode: Mode$1;

    /**
     * When true, includes the `range` key on each token.
     */
    readonly ranges: boolean;
}

/**
 * Parse options.
 */
interface ParseOptions$1 {

    /**
     * The mode to parse in.
     */
    readonly mode: Mode$1;

    /**
     * When true, includes the `range` key on each node and token.
     */
    readonly ranges: boolean;

    /**
     * When true, includes the `tokens` key on the document node containing
     * all of the tokens used during parsing.
     */
    readonly tokens: boolean;

    /**
     * When true, allows trailing commas in arrays and objects. Defaults to
     * false for JSON and JSONC modes, and true for JSON5 mode.
     */
    readonly allowTrailingCommas: boolean;
}

//-----------------------------------------------------------------------------
// Nodes
//-----------------------------------------------------------------------------

interface Node$1 {
    type: string;
    loc: LocationRange;
    range?: Range$1;
}

/**
 * The root node of a JSON document.
 */
interface DocumentNode$1 extends Node$1 {
    type: "Document";
    body: ValueNode$1;
    tokens?: Array<Token$1>;
}

interface NullNode$1 extends Node$1 {
    type: "Null";
}

interface LiteralNode<T> extends Node$1 {
    value: T;
}

/**
 * Represents a JSON5 NaN value.
 */
interface NaNNode$1 extends Node$1 {
    type: "NaN";
    sign: Sign$1;
}

/**
 * Represents a JSON5 Infinity value.
 */
interface InfinityNode$1 extends Node$1 {
    type: "Infinity";
    sign: Sign$1;
}

/**
 * Represents a JSON identifier.
 */
interface IdentifierNode$1 extends Node$1 {
    type: "Identifier";
    name: string;
}

/**
 * Represents a JSON string.
 */
interface StringNode$1 extends LiteralNode<string> {
    type: "String";
}

/**
 * Represents a JSON number.
 */
interface NumberNode$1 extends LiteralNode<number> {
    type: "Number";
}

/**
 * Represents a JSON boolean.
 */
interface BooleanNode$1 extends LiteralNode<boolean> {
    type: "Boolean";
}

/**
 * Represents an element of a JSON array.
 */
interface ElementNode$1 extends Node$1 {
    type: "Element";
    value: ValueNode$1;
}

/**
 * Represents a JSON array.
 */
interface ArrayNode$1 extends Node$1 {
    type: "Array";
    elements: Array<ElementNode$1>;
}

/**
 * Represents a member of a JSON object.
 */
interface MemberNode$1 extends Node$1 {
    type: "Member";
    name: StringNode$1 | IdentifierNode$1;
    value: ValueNode$1;
}

/**
 * Represents a JSON object.
 */
interface ObjectNode$1 extends Node$1 {
    type: "Object";
    members: Array<MemberNode$1>;
}

/**
 * Any node that represents a JSON value.
 */
type ValueNode$1 = ArrayNode$1 | ObjectNode$1 | 
    BooleanNode$1 | StringNode$1 | NumberNode$1 | NullNode$1 |
    NaNNode$1 | InfinityNode$1;

/**
 * Any node that represents the container for a JSON value.
 */
type ContainerNode = DocumentNode$1 | MemberNode$1 | ElementNode$1;

/**
 * Any node that represents a JSON5 extension.
 */
type JSON5ExtensionNode = NaNNode$1 | InfinityNode$1 | IdentifierNode$1;

/**
 * Any valid AST node.
 */
type AnyNode$1 = ValueNode$1 | ContainerNode | JSON5ExtensionNode;

/**
 * Additional information about an AST node.
 */
interface NodeParts$1 {
    loc?: LocationRange;
    range?: Range$1;
}

//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------

/**
 * Values that can be represented in JSON.
 */
type JSONValue$1 =
    | Array<JSONValue$1>
    | boolean
    | number
    | string
    | { [property: string]: JSONValue$1 }
    | null;

//-----------------------------------------------------------------------------
// Tokens
//-----------------------------------------------------------------------------

/**
 * A token used to during JSON parsing.
 */
interface Token$1 {
    type: TokenType$1;
    loc: LocationRange;
    range?: Range$1;
}

/**
 * The type of token.
 */
type TokenType$1 = "Number" | "String" | "Boolean" | "Colon" | "LBrace" |
    "RBrace" | "RBracket" | "LBracket" | "Comma" | "Null" | "LineComment" |
    "BlockComment" | "NaN" | "Infinity" | "Identifier";

//-----------------------------------------------------------------------------
// Location Related
//-----------------------------------------------------------------------------

/**
 * The start and stop location for a token or node inside the source text.
 */
interface LocationRange {
    start: Location$1;
    end: Location$1;
}

/**
 * A cursor location inside the source text.
 */
interface Location$1 {
    line: number;
    column: number;
    offset: number;
}

/**
 * The start and stop offset for a given node or token inside the source text.
 */
type Range$1 = [number, number];

type FilterPredicate = (item: {
    node: Node;
    parent?: Node;
    phase: TraversalPhase;
}, index: number, array: Array<{
    node: Node;
    parent?: Node;
    phase: TraversalPhase;
}>) => boolean;
type AnyNode = AnyNode$1;
type JSONValue = JSONValue$1;
type TokenType = TokenType$1;
type Location = Location$1;
type Token = Token$1;
type Range = Range$1;
type TokenizeOptions = TokenizeOptions$1;
type NodeParts = NodeParts$1;
type DocumentNode = DocumentNode$1;
type StringNode = StringNode$1;
type NumberNode = NumberNode$1;
type BooleanNode = BooleanNode$1;
type MemberNode = MemberNode$1;
type ObjectNode = ObjectNode$1;
type ElementNode = ElementNode$1;
type ArrayNode = ArrayNode$1;
type NullNode = NullNode$1;
type ValueNode = ValueNode$1;
type IdentifierNode = IdentifierNode$1;
type NaNNode = NaNNode$1;
type InfinityNode = InfinityNode$1;
type Sign = Sign$1;
type Node = Node$1;
type Mode = Mode$1;
type ParseOptions = ParseOptions$1;
type TraversalPhase = TraversalPhase$1;
/**
 * @fileoverview Evaluator for Momoa AST.
 * @author Nicholas C. Zakas
 */
/** @typedef {import("./typedefs.ts").AnyNode} AnyNode */
/** @typedef {import("./typedefs.ts").JSONValue} JSONValue */
/**
 * Evaluates a Momoa AST node into a JavaScript value.
 * @param {AnyNode} node The node to interpet.
 * @returns {JSONValue} The JavaScript value for the node.
 */
declare function evaluate(node: AnyNode): JSONValue;
/**
 * @callback FilterPredicate
 * @param {{node: Node, parent?: Node, phase: TraversalPhase}} item
 * @param {number} index
 * @param {Array<{node: Node, parent?: Node, phase: TraversalPhase}>} array
 * @returns {boolean}
 */
/**
 * Creates an iterator over the given AST.
 * @param {Node} root The root AST node to traverse.
 * @param {FilterPredicate} [filter] A filter function to determine which steps to
 *      return;
 * @returns {IterableIterator<{node: Node, parent?: Node, phase: TraversalPhase}>} An iterator over the AST.
 */
declare function iterator(root: Node, filter?: FilterPredicate): IterableIterator<{
    node: Node;
    parent?: Node;
    phase: TraversalPhase;
}>;
/**
 *
 * @param {string} text The text to parse.
 * @param {ParseOptions} [options] The options object.
 * @returns {DocumentNode} The AST representing the parsed JSON.
 * @throws {Error} When there is a parsing error.
 */
declare function parse(text: string, options?: ParseOptions): DocumentNode;
/**
 * Converts a Momoa AST back into a JSON string.
 * @param {AnyNode} node The node to print.
 * @param {Object} options Options for the print.
 * @param {number} [options.indent=0] The number of spaces to indent each line. If
 *      greater than 0, then newlines and indents will be added to output.
 * @returns {string} The JSON representation of the AST.
 */
declare function print(node: AnyNode, { indent }?: {
    indent?: number;
}): string;
/**
 * Creates an iterator over the tokens representing the source text.
 * @param {string} text The source text to tokenize.
 * @param {TokenizeOptions} options Options for doing the tokenization.
 * @returns {Array<Token>} An iterator over the tokens.
 */
declare function tokenize(text: string, options: TokenizeOptions): Array<Token>;
/**
 * Traverses an AST from the given node.
 * @param {Node} root The node to traverse from
 * @param {Object} visitor An object with an `enter` and `exit` method.
 */
declare function traverse(root: Node, visitor: any): void;
declare namespace types {
    /**
     * Creates a document node.
     * @param {ValueNode} body The body of the document.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {DocumentNode} The document node.
     */
    export function document(body: ValueNode, parts?: NodeParts): DocumentNode;
    /**
     * Creates a string node.
     * @param {string} value The value for the string.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {StringNode} The string node.
     */
    export function string(value: string, parts?: NodeParts): StringNode;
    /**
     * Creates a number node.
     * @param {number} value The value for the number.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {NumberNode} The number node.
     */
    export function number(value: number, parts?: NodeParts): NumberNode;
    /**
     * Creates a boolean node.
     * @param {boolean} value The value for the boolean.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {BooleanNode} The boolean node.
     */
    export function boolean(value: boolean, parts?: NodeParts): BooleanNode;
    /**
     * Creates a null node.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {NullNode} The null node.
     */
    function _null(parts?: NodeParts): NullNode;
    export { _null as null };
    /**
     * Creates an array node.
     * @param {Array<ElementNode>} elements The elements to add.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {ArrayNode} The array node.
     */
    export function array(elements: Array<ElementNode>, parts?: NodeParts): ArrayNode;
    /**
     * Creates an element node.
     * @param {ValueNode} value The value for the element.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {ElementNode} The element node.
     */
    export function element(value: ValueNode, parts?: NodeParts): ElementNode;
    /**
     * Creates an object node.
     * @param {Array<MemberNode>} members The members to add.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {ObjectNode} The object node.
     */
    export function object(members: Array<MemberNode>, parts?: NodeParts): ObjectNode;
    /**
     * Creates a member node.
     * @param {StringNode|IdentifierNode} name The name for the member.
     * @param {ValueNode} value The value for the member.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {MemberNode} The member node.
     */
    export function member(name: StringNode | IdentifierNode, value: ValueNode, parts?: NodeParts): MemberNode;
    /**
     * Creates an identifier node.
     * @param {string} name The name for the identifier.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {IdentifierNode} The identifier node.
     */
    export function identifier(name: string, parts?: NodeParts): IdentifierNode;
    /**
     * Creates a NaN node.
     * @param {Sign} sign The sign for the Infinity.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {NaNNode} The NaN node.
     */
    export function nan(sign?: Sign, parts?: NodeParts): NaNNode;
    /**
     * Creates an Infinity node.
     * @param {Sign} sign The sign for the Infinity.
     * @param {NodeParts} parts Additional properties for the node.
     * @returns {InfinityNode} The Infinity node.
     */
    export function infinity(sign?: Sign, parts?: NodeParts): InfinityNode;
}
/**
 * @fileoverview Traversal approaches for Momoa JSON AST.
 * @author Nicholas C. Zakas
 */
/** @typedef {import("./typedefs.ts").TraversalPhase} TraversalPhase */
declare const childKeys: Map<string, string[]>;

export { type AnyNode, type ArrayNode, type BooleanNode, type DocumentNode, type ElementNode, type FilterPredicate, type IdentifierNode, type InfinityNode, type JSONValue, type Location, type MemberNode, type Mode, type NaNNode, type Node, type NodeParts, type NullNode, type NumberNode, type ObjectNode, type ParseOptions, type Range, type Sign, type StringNode, type Token, type TokenType, type TokenizeOptions, type TraversalPhase, type ValueNode, evaluate, iterator, parse, print, tokenize, traverse, types, childKeys as visitorKeys };
export type { ContainerNode, LocationRange };
