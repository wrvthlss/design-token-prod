function _transformDimension(dim) {
    // Check if the value is numeric with isNaN, this supports string values as well
    // Check if value is not empty string, since this is also not considered "NaN"
    // Check if the value, when parsed (since it can also be number), does not equal 0
    if (!isNaN(dim) && dim !== '' && parseFloat(dim) !== 0) {
        return `${dim}px`;
    }
    return `${dim}`;
}
/**
 * Helper: Transforms dimensions to px
 */
export function transformDimension(token) {
    const val = (token.$value ?? token.value);
    const type = token.$type ?? token.type;
    if (val === undefined)
        return undefined;
    const transformProp = (val, prop) => {
        if (val[prop] !== undefined) {
            val[prop] = _transformDimension(val[prop]);
        }
        return val;
    };
    let transformed = val;
    switch (type) {
        case 'typography': {
            transformed = transformed;
            transformed = transformProp(transformed, 'fontSize');
            break;
        }
        case 'shadow': {
            transformed = transformed;
            const transformShadow = (shadowVal) => {
                ['offsetX', 'offsetY', 'blur', 'spread'].forEach(prop => {
                    shadowVal = transformProp(shadowVal, prop);
                });
                return shadowVal;
            };
            if (Array.isArray(transformed)) {
                transformed = transformed.map(transformShadow);
            }
            else {
                transformed = transformShadow(transformed);
            }
            break;
        }
        case 'border': {
            transformed = transformed;
            transformed = transformProp(transformed, 'width');
            break;
        }
        default:
            transformed = transformed;
            transformed = _transformDimension(transformed);
    }
    return transformed;
}
